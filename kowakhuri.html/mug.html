<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>The Divine Chalice</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Philosopher&display=swap');
  
  html, body {
    margin: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(180deg, #0a0a15 0%, #1a1025 50%, #0d0d18 100%);
    overflow: hidden;
    font-family: 'Cinzel', serif;
  }
  canvas { display: block; cursor: default; }
  .back-link {
    position: fixed;
    top: 20px;
    left: 20px;
    font-size: 12px;
    font-weight: bold;
    color: #ffd700;
    text-decoration: none;
    letter-spacing: 2px;
    text-transform: uppercase;
    padding: 10px 20px;
    border: 1px solid #ffd700;
    transition: all 0.3s ease;
    z-index: 100;
    background: rgba(0,0,0,0.8);
  }
  .back-link:hover {
    background: #ffd700;
    color: #0a0a12;
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
  }
  .title {
    position: fixed;
    top: 30px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 26px;
    font-weight: 700;
    color: #ffd700;
    letter-spacing: 6px;
    text-transform: uppercase;
    z-index: 100;
    text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
  }
  .subtitle {
    position: fixed;
    top: 70px;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'Philosopher', sans-serif;
    font-size: 14px;
    color: rgba(255, 215, 0, 0.5);
    letter-spacing: 3px;
    z-index: 100;
    font-style: italic;
  }
  .hint {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'Philosopher', sans-serif;
    font-size: 13px;
    color: rgba(255, 215, 0, 0.4);
    letter-spacing: 2px;
    z-index: 100;
  }
</style>
</head>
<body>

<a href="kow.html" class="back-link">Return to Olympus</a>
<div class="title">Divine Chalice</div>
<div class="subtitle">Vessel of the Gods</div>
<div class="hint">Hover to awaken | Click to view the collection</div>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

let W, H;
function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
resize();
window.addEventListener("resize", resize);

let mouse = { x: W/2, y: H/2, over: false };
let rotation = 0;
let rotationSpeed = 0;
let targetRotationSpeed = 0;

canvas.addEventListener("mousemove", e => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
  const dx = mouse.x - W/2;
  const dy = mouse.y - H/2;
  mouse.over = Math.sqrt(dx * dx + dy * dy) < 280;
});

canvas.addEventListener("mouseleave", () => { mouse.over = false; });

canvas.addEventListener("click", () => {
  if (mouse.over) window.location.href = "mug-gallery.html";
});

const VOXEL_SIZE = 14;

function createChaliceVoxels() {
  const voxels = [];
  
  // Chalice parameters
  const cupRadius = 7;
  const cupHeight = 8;
  const stemHeight = 6;
  const stemRadius = 2;
  const baseRadius = 5;
  const baseHeight = 2;
  
  // Base of chalice
  for (let y = 0; y < baseHeight; y++) {
    for (let x = -baseRadius; x <= baseRadius; x++) {
      for (let z = -baseRadius; z <= baseRadius; z++) {
        const dist = Math.sqrt(x * x + z * z);
        if (dist <= baseRadius - y * 0.5) {
          voxels.push({ x, y, z, color: y === 0 ? "#B8860B" : "#DAA520" });
        }
      }
    }
  }
  
  // Stem
  for (let y = baseHeight; y < baseHeight + stemHeight; y++) {
    for (let x = -stemRadius; x <= stemRadius; x++) {
      for (let z = -stemRadius; z <= stemRadius; z++) {
        const dist = Math.sqrt(x * x + z * z);
        if (dist <= stemRadius) {
          const shimmer = (y % 2 === 0) ? "#DAA520" : "#FFD700";
          voxels.push({ x, y, z, color: shimmer });
        }
      }
    }
  }
  
  // Cup bowl (expanding upward)
  const cupBase = baseHeight + stemHeight;
  for (let y = 0; y < cupHeight; y++) {
    const t = y / cupHeight;
    const radius = stemRadius + (cupRadius - stemRadius) * Math.pow(t, 0.6);
    const innerRadius = Math.max(0, radius - 1);
    
    for (let x = -cupRadius; x <= cupRadius; x++) {
      for (let z = -cupRadius; z <= cupRadius; z++) {
        const dist = Math.sqrt(x * x + z * z);
        
        // Outer wall
        if (dist <= radius && dist >= innerRadius) {
          let color;
          if (y === cupHeight - 1) {
            color = "#FFD700"; // Gold rim
          } else {
            color = dist > radius - 0.5 ? "#DAA520" : "#B8860B";
          }
          voxels.push({ x, y: y + cupBase, z, color });
        }
        
        // Bottom of cup
        if (y === 0 && dist < innerRadius) {
          voxels.push({ x, y: y + cupBase, z, color: "#8B7355" });
        }
      }
    }
  }
  
  // Divine nectar inside
  const nectarLevel = cupBase + cupHeight - 3;
  for (let y = cupBase + 1; y <= nectarLevel; y++) {
    const t = (y - cupBase) / cupHeight;
    const radius = stemRadius + (cupRadius - stemRadius) * Math.pow(t, 0.6) - 1.5;
    
    for (let x = -cupRadius; x <= cupRadius; x++) {
      for (let z = -cupRadius; z <= cupRadius; z++) {
        const dist = Math.sqrt(x * x + z * z);
        if (dist < radius) {
          const nectarColor = y === nectarLevel ? "#9B30FF" : "#7B68EE";
          voxels.push({ x, y, z, color: nectarColor, nectar: true });
        }
      }
    }
  }
  
  // Magical particles above
  for (let i = 0; i < 12; i++) {
    const angle = (i / 12) * Math.PI * 2;
    const r = 2 + Math.random() * 3;
    voxels.push({
      x: Math.cos(angle) * r,
      y: cupBase + cupHeight + 1 + Math.random() * 3,
      z: Math.sin(angle) * r,
      color: "#E6E6FA",
      magic: true
    });
  }
  
  return voxels;
}

let voxels = createChaliceVoxels();

function project(x, y, z, rotY) {
  const cosR = Math.cos(rotY);
  const sinR = Math.sin(rotY);
  const rx = x * cosR - z * sinR;
  const rz = x * sinR + z * cosR;
  
  const isoX = (rx - rz) * VOXEL_SIZE;
  const isoY = ((rx + rz) / 2 - y) * VOXEL_SIZE;
  
  return { x: W/2 + isoX, y: H/2 + isoY + 80, depth: rz };
}

function drawVoxel(x, y, z, color, rotY) {
  const p = project(x, y, z, rotY);
  const size = VOXEL_SIZE;
  
  const topColor = color;
  const rightColor = shadeColor(color, -25);
  const leftColor = shadeColor(color, -50);
  
  const top = { x: p.x, y: p.y - size };
  const topLeft = { x: p.x - size, y: p.y - size * 1.5 };
  const topRight = { x: p.x + size, y: p.y - size * 1.5 };
  
  // Top face
  ctx.fillStyle = topColor;
  ctx.beginPath();
  ctx.moveTo(top.x, top.y - size/2);
  ctx.lineTo(topRight.x, top.y);
  ctx.lineTo(top.x, top.y + size/2);
  ctx.lineTo(topLeft.x, top.y);
  ctx.closePath();
  ctx.fill();
  
  // Left face
  ctx.fillStyle = leftColor;
  ctx.beginPath();
  ctx.moveTo(topLeft.x, top.y);
  ctx.lineTo(top.x, top.y + size/2);
  ctx.lineTo(top.x, p.y + size/2);
  ctx.lineTo(topLeft.x, p.y);
  ctx.closePath();
  ctx.fill();
  
  // Right face
  ctx.fillStyle = rightColor;
  ctx.beginPath();
  ctx.moveTo(top.x, top.y + size/2);
  ctx.lineTo(topRight.x, top.y);
  ctx.lineTo(topRight.x, p.y);
  ctx.lineTo(top.x, p.y + size/2);
  ctx.closePath();
  ctx.fill();
}

function shadeColor(color, percent) {
  if (color.startsWith("rgba") || color.startsWith("hsla")) return color;
  let R = parseInt(color.substring(1, 3), 16);
  let G = parseInt(color.substring(3, 5), 16);
  let B = parseInt(color.substring(5, 7), 16);
  R = Math.min(255, Math.max(0, R + percent));
  G = Math.min(255, Math.max(0, G + percent));
  B = Math.min(255, Math.max(0, B + percent));
  return "#" + ((1 << 24) + (R << 16) + (G << 8) + B).toString(16).slice(1);
}

// Background stars
const stars = [];
for (let i = 0; i < 150; i++) {
  stars.push({
    x: Math.random() * 2000,
    y: Math.random() * 2000,
    size: Math.random() * 2,
    twinkle: Math.random() * Math.PI * 2
  });
}

let time = 0;

function draw() {
  // Cosmic background
  const bgGradient = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H) * 0.7);
  bgGradient.addColorStop(0, "#1a1028");
  bgGradient.addColorStop(0.5, "#0d0d18");
  bgGradient.addColorStop(1, "#050508");
  ctx.fillStyle = bgGradient;
  ctx.fillRect(0, 0, W, H);
  
  // Stars
  stars.forEach(star => {
    const twinkle = 0.2 + Math.sin(star.twinkle + time * 2) * 0.3;
    ctx.fillStyle = `rgba(255, 255, 255, ${twinkle})`;
    ctx.beginPath();
    ctx.arc(star.x % W, star.y % H, star.size, 0, Math.PI * 2);
    ctx.fill();
  });
  
  // Update rotation
  targetRotationSpeed = mouse.over ? 0.035 : 0.004;
  rotationSpeed += (targetRotationSpeed - rotationSpeed) * 0.05;
  rotation += rotationSpeed;
  
  // Sort voxels
  const sortedVoxels = voxels.map(v => {
    const depth = v.x * Math.sin(rotation) + v.z * Math.cos(rotation);
    return { ...v, depth };
  }).sort((a, b) => a.depth - b.depth);
  
  // Shadow
  ctx.fillStyle = "rgba(0,0,0,0.4)";
  ctx.beginPath();
  ctx.ellipse(W/2 + 30, H/2 + 220, 140, 50, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Draw voxels
  sortedVoxels.forEach(v => {
    if (v.magic) {
      const magicOffset = Math.sin(time * 3 + v.x + v.z) * 2;
      const magicY = v.y + Math.sin(time * 2 + v.x) * 0.5;
      const p = project(v.x + magicOffset, magicY, v.z, rotation);
      
      ctx.fillStyle = `rgba(230, 230, 250, ${0.4 + Math.sin(time * 2 + v.x) * 0.3})`;
      ctx.shadowColor = "#E6E6FA";
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 6 + Math.sin(time * 2) * 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    } else if (v.nectar) {
      // Glowing nectar
      ctx.shadowColor = "#9B30FF";
      ctx.shadowBlur = 8;
      drawVoxel(v.x, v.y, v.z, v.color, rotation);
      ctx.shadowBlur = 0;
    } else {
      drawVoxel(v.x, v.y, v.z, v.color, rotation);
    }
  });
  
  // Glow when spinning
  if (rotationSpeed > 0.015) {
    const glowIntensity = (rotationSpeed - 0.015) * 15;
    ctx.fillStyle = `rgba(255, 215, 0, ${glowIntensity * 0.1})`;
    ctx.beginPath();
    ctx.arc(W/2, H/2 + 50, 220, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Cursor indicator
  if (mouse.over) {
    canvas.style.cursor = "pointer";
  } else {
    canvas.style.cursor = "default";
  }
  
  time += 0.02;
  requestAnimationFrame(draw);
}

draw();
</script>

</body>
</html>
