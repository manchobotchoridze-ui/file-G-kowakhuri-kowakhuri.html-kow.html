<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Sacred Symbols - Sun & Moon</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Philosopher&display=swap');
  
  html, body {
    margin: 0;
    width: 100%;
    height: 100%;
    background: #0a0a12;
    overflow: hidden;
  }
  canvas {
    display: block;
    cursor: default;
  }
  .back-link {
    position: fixed;
    top: 20px;
    left: 20px;
    font-family: 'Cinzel', serif;
    font-size: 12px;
    font-weight: bold;
    color: #ffd700;
    text-decoration: none;
    letter-spacing: 2px;
    text-transform: uppercase;
    padding: 10px 20px;
    border: 1px solid #ffd700;
    transition: all 0.3s ease;
    z-index: 100;
    background: rgba(10, 10, 18, 0.9);
  }
  .back-link:hover {
    background: #ffd700;
    color: #0a0a12;
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
  }
  .title {
    position: fixed;
    top: 30px;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'Cinzel', serif;
    font-size: 28px;
    font-weight: 700;
    color: #ffd700;
    letter-spacing: 6px;
    text-transform: uppercase;
    z-index: 100;
    text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
  }
  .subtitle {
    position: fixed;
    top: 75px;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'Philosopher', sans-serif;
    font-size: 14px;
    color: rgba(255, 215, 0, 0.5);
    letter-spacing: 3px;
    z-index: 100;
    font-style: italic;
  }
  .labels {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 200px;
    z-index: 100;
  }
  .label {
    font-family: 'Cinzel', serif;
    font-size: 16px;
    color: rgba(255, 255, 255, 0.6);
    letter-spacing: 4px;
    text-transform: uppercase;
  }
  .label.sun { color: rgba(255, 180, 0, 0.7); }
  .label.moon { color: rgba(200, 200, 255, 0.7); }
</style>
</head>
<body>

<a href="kow.html" class="back-link">Return to Olympus</a>
<div class="title">Sacred Symbols</div>
<div class="subtitle">Apollo & Artemis - The Divine Twins</div>
<div class="labels">
  <span class="label sun">Helios</span>
  <span class="label moon">Selene</span>
</div>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

let W, H;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  
  circle1.cx = W / 2 - 180;
  circle1.cy = H / 2;
  circle2.cx = W / 2 + 180;
  circle2.cy = H / 2;
}

// Mouse tracking
let mouse = { x: -1000, y: -1000 };
const EXPLOSION_RADIUS = 100;
const EXPLOSION_FORCE = 20;

canvas.addEventListener("mousemove", e => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
});

canvas.addEventListener("mouseleave", () => {
  mouse.x = -1000;
  mouse.y = -1000;
});

// Click detection for circles
canvas.addEventListener("click", e => {
  const clickX = e.clientX;
  const clickY = e.clientY;
  
  const dist1 = Math.sqrt(Math.pow(clickX - circle1.cx, 2) + Math.pow(clickY - circle1.cy, 2));
  const dist2 = Math.sqrt(Math.pow(clickX - circle2.cx, 2) + Math.pow(clickY - circle2.cy, 2));
  
  if (dist1 <= CIRCLE_RADIUS || dist2 <= CIRCLE_RADIUS) {
    window.location.href = "posters.html";
  }
});

canvas.addEventListener("mousemove", e => {
  const dist1 = Math.sqrt(Math.pow(e.clientX - circle1.cx, 2) + Math.pow(e.clientY - circle1.cy, 2));
  const dist2 = Math.sqrt(Math.pow(e.clientX - circle2.cx, 2) + Math.pow(e.clientY - circle2.cy, 2));
  
  canvas.style.cursor = (dist1 <= CIRCLE_RADIUS || dist2 <= CIRCLE_RADIUS) ? "pointer" : "default";
});

const CIRCLE_RADIUS = 130;
const PARTICLES_PER_CIRCLE = 500;
const ROTATION_SPEED = 0.006;

let rotation = 0;
let time = 0;

// Sun (Helios) and Moon (Selene)
const circle1 = { cx: 0, cy: 0, particles: [], rotationDir: 1, type: "sun" };
const circle2 = { cx: 0, cy: 0, particles: [], rotationDir: -1, type: "moon" };

function createCircleParticle(circleRadius, type) {
  const angle = Math.random() * Math.PI * 2;
  const edgeBias = Math.pow(Math.random(), 0.5);
  const distance = edgeBias * circleRadius;
  
  let size = 1 + Math.random() * 2;
  if (Math.random() < 0.08) size = 2 + Math.random() * 2;
  
  const opacity = 0.3 + (distance / circleRadius) * 0.5;
  
  return {
    baseAngle: angle,
    baseDistance: distance,
    size,
    opacity,
    speedMult: 0.5 + Math.random() * 1,
    vx: 0,
    vy: 0,
    offsetX: 0,
    offsetY: 0,
    type
  };
}

// Initialize particles
for (let i = 0; i < PARTICLES_PER_CIRCLE; i++) {
  circle1.particles.push(createCircleParticle(CIRCLE_RADIUS, "sun"));
  circle2.particles.push(createCircleParticle(CIRCLE_RADIUS, "moon"));
}

// Ring particles
for (let i = 0; i < 200; i++) {
  const angle = (i / 200) * Math.PI * 2;
  const wobble = (Math.random() - 0.5) * 15;
  
  circle1.particles.push({
    baseAngle: angle,
    baseDistance: CIRCLE_RADIUS + wobble,
    size: 1 + Math.random() * 1.5,
    opacity: 0.5 + Math.random() * 0.3,
    speedMult: 0.8 + Math.random() * 0.4,
    vx: 0, vy: 0, offsetX: 0, offsetY: 0,
    type: "sun"
  });
  
  circle2.particles.push({
    baseAngle: angle,
    baseDistance: CIRCLE_RADIUS + wobble,
    size: 1 + Math.random() * 1.5,
    opacity: 0.5 + Math.random() * 0.3,
    speedMult: 0.8 + Math.random() * 0.4,
    vx: 0, vy: 0, offsetX: 0, offsetY: 0,
    type: "moon"
  });
}

// Stars background
const stars = [];
for (let i = 0; i < 200; i++) {
  stars.push({
    x: Math.random() * 2000,
    y: Math.random() * 2000,
    size: Math.random() * 1.5,
    twinkle: Math.random() * Math.PI * 2
  });
}

function updateAndDrawCircle(circle) {
  circle.particles.forEach(p => {
    const angle = p.baseAngle + rotation * p.speedMult * circle.rotationDir;
    
    const targetX = circle.cx + Math.cos(angle) * p.baseDistance;
    const targetY = circle.cy + Math.sin(angle) * p.baseDistance;
    
    const actualX = targetX + p.offsetX;
    const actualY = targetY + p.offsetY;
    
    const dx = actualX - mouse.x;
    const dy = actualY - mouse.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist < EXPLOSION_RADIUS && dist > 0) {
      const force = (1 - dist / EXPLOSION_RADIUS) * EXPLOSION_FORCE;
      p.vx += (dx / dist) * force;
      p.vy += (dy / dist) * force;
    }
    
    p.offsetX += p.vx;
    p.offsetY += p.vy;
    p.vx *= 0.9;
    p.vy *= 0.9;
    p.offsetX *= 0.94;
    p.offsetY *= 0.94;
    
    const finalX = targetX + p.offsetX;
    const finalY = targetY + p.offsetY;
    
    // Color based on type
    let hue, saturation, lightness;
    if (p.type === "sun") {
      hue = 35 + (p.baseDistance / CIRCLE_RADIUS) * 20;
      saturation = 100;
      lightness = 55 + (1 - p.baseDistance / CIRCLE_RADIUS) * 15;
    } else {
      hue = 220 + (p.baseDistance / CIRCLE_RADIUS) * 40;
      saturation = 30 + (p.baseDistance / CIRCLE_RADIUS) * 40;
      lightness = 60 + (1 - p.baseDistance / CIRCLE_RADIUS) * 20;
    }
    
    ctx.beginPath();
    ctx.arc(finalX, finalY, p.size, 0, Math.PI * 2);
    ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${p.opacity})`;
    ctx.fill();
  });
  
  // Draw center glow
  const gradient = ctx.createRadialGradient(circle.cx, circle.cy, 0, circle.cx, circle.cy, 50);
  
  if (circle.type === "sun") {
    gradient.addColorStop(0, "rgba(255, 200, 50, 0.9)");
    gradient.addColorStop(0.5, "rgba(255, 150, 0, 0.4)");
    gradient.addColorStop(1, "rgba(255, 100, 0, 0)");
  } else {
    gradient.addColorStop(0, "rgba(200, 210, 255, 0.8)");
    gradient.addColorStop(0.5, "rgba(150, 160, 255, 0.3)");
    gradient.addColorStop(1, "rgba(100, 100, 200, 0)");
  }
  
  ctx.beginPath();
  ctx.arc(circle.cx, circle.cy, 50, 0, Math.PI * 2);
  ctx.fillStyle = gradient;
  ctx.fill();
}

function draw() {
  // Cosmic background
  const bgGradient = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H) * 0.7);
  bgGradient.addColorStop(0, "#12101a");
  bgGradient.addColorStop(1, "#050508");
  ctx.fillStyle = bgGradient;
  ctx.fillRect(0, 0, W, H);
  
  // Stars
  stars.forEach(star => {
    const twinkle = 0.2 + Math.sin(star.twinkle + time * 2) * 0.2;
    ctx.fillStyle = `rgba(255, 255, 255, ${twinkle})`;
    ctx.beginPath();
    ctx.arc(star.x % W, star.y % H, star.size, 0, Math.PI * 2);
    ctx.fill();
  });
  
  updateAndDrawCircle(circle1);
  updateAndDrawCircle(circle2);
  
  // Divine connection between sun and moon
  const midX = (circle1.cx + circle2.cx) / 2;
  const midY = (circle1.cy + circle2.cy) / 2;
  
  for (let i = 0; i < 8; i++) {
    const t = (Math.sin(time * 2 + i * 0.5) + 1) / 2;
    const x = circle1.cx + (circle2.cx - circle1.cx) * t;
    const y = midY + Math.sin(time * 3 + i) * 30;
    
    const hue = 35 + t * 185;
    ctx.beginPath();
    ctx.arc(x, y, 2 + Math.sin(time + i) * 1, 0, Math.PI * 2);
    ctx.fillStyle = `hsla(${hue}, 70%, 60%, ${0.3 + Math.sin(time + i) * 0.2})`;
    ctx.fill();
  }
  
  rotation += ROTATION_SPEED;
  time += 0.02;
  
  requestAnimationFrame(draw);
}

resize();
window.addEventListener("resize", resize);
draw();
</script>

</body>
</html>
